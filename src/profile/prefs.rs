use anyhow::{Context, Result};
use std::collections::HashMap;
use std::path::Path;

use crate::events::PrefValue;

pub fn read_prefs(profile_path: &Path, whitelist: &[String]) -> Result<HashMap<String, PrefValue>> {
    let prefs_path = profile_path.join("prefs.js");
    let content = std::fs::read_to_string(&prefs_path)
        .with_context(|| format!("Failed to read {}", prefs_path.display()))?;

    let mut prefs = HashMap::new();

    for line in content.lines() {
        let line = line.trim();
        if !line.starts_with("user_pref(") {
            continue;
        }

        if let Some((key, value)) = parse_pref_line(line)
            && should_include(&key, whitelist)
        {
            prefs.insert(key, value);
        }
    }

    Ok(prefs)
}

fn parse_pref_line(line: &str) -> Option<(String, PrefValue)> {
    // user_pref("key", value);
    let line = line.strip_prefix("user_pref(")?;
    let line = line.strip_suffix(");")?;

    let (key, value) = line.split_once(", ")?;

    // Remove quotes from key
    let key = key.trim_matches('"').to_string();

    // Parse value
    let value = if value == "true" {
        PrefValue::Bool(true)
    } else if value == "false" {
        PrefValue::Bool(false)
    } else if let Ok(n) = value.parse::<i64>() {
        PrefValue::Int(n)
    } else if value.starts_with('"') && value.ends_with('"') {
        PrefValue::String(value[1..value.len() - 1].to_string())
    } else {
        return None;
    };

    Some((key, value))
}

fn should_include(key: &str, whitelist: &[String]) -> bool {
    for pattern in whitelist {
        if pattern.ends_with('*') {
            let prefix = &pattern[..pattern.len() - 1];
            if key.starts_with(prefix) {
                return true;
            }
        } else if pattern == key {
            return true;
        }
    }
    false
}

pub fn write_user_js(profile_path: &Path, prefs: &HashMap<String, PrefValue>) -> Result<()> {
    let user_js_path = profile_path.join("user.js");

    let mut lines: Vec<String> = vec![
        "// Generated by wolfpack".to_string(),
        "// Do not edit manually - changes will be overwritten".to_string(),
        String::new(),
    ];

    let mut sorted_prefs: Vec<_> = prefs.iter().collect();
    sorted_prefs.sort_by_key(|(k, _)| *k);

    for (key, value) in sorted_prefs {
        let value_str = match value {
            PrefValue::Bool(b) => b.to_string(),
            PrefValue::Int(n) => n.to_string(),
            PrefValue::String(s) => format!("\"{}\"", s.replace('\\', "\\\\").replace('"', "\\\"")),
        };
        lines.push(format!("user_pref(\"{}\", {});", key, value_str));
    }

    std::fs::write(&user_js_path, lines.join("\n"))
        .with_context(|| format!("Failed to write {}", user_js_path.display()))?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    #[test]
    fn test_parse_pref_line() {
        let cases = vec![
            (
                r#"user_pref("test.bool", true);"#,
                Some(("test.bool".to_string(), PrefValue::Bool(true))),
            ),
            (
                r#"user_pref("test.int", 42);"#,
                Some(("test.int".to_string(), PrefValue::Int(42))),
            ),
            (
                r#"user_pref("test.string", "hello");"#,
                Some((
                    "test.string".to_string(),
                    PrefValue::String("hello".to_string()),
                )),
            ),
        ];

        for (input, expected) in cases {
            assert_eq!(parse_pref_line(input), expected);
        }
    }

    #[test]
    fn test_parse_pref_line_false() {
        let result = parse_pref_line(r#"user_pref("test.bool", false);"#);
        assert_eq!(
            result,
            Some(("test.bool".to_string(), PrefValue::Bool(false)))
        );
    }

    #[test]
    fn test_parse_pref_line_negative_int() {
        let result = parse_pref_line(r#"user_pref("test.int", -42);"#);
        assert_eq!(result, Some(("test.int".to_string(), PrefValue::Int(-42))));
    }

    #[test]
    fn test_parse_pref_line_invalid() {
        // Not a user_pref line
        assert_eq!(parse_pref_line("// comment"), None);
        assert_eq!(parse_pref_line("pref(\"key\", \"value\");"), None);

        // Missing semicolon
        assert_eq!(parse_pref_line(r#"user_pref("key", "value")"#), None);

        // Missing closing paren
        assert_eq!(parse_pref_line(r#"user_pref("key", "value";"#), None);

        // Invalid value (not bool, int, or string)
        assert_eq!(parse_pref_line(r#"user_pref("key", undefined);"#), None);
    }

    #[test]
    fn test_write_user_js() {
        let dir = tempdir().unwrap();
        let mut prefs = HashMap::new();
        prefs.insert("test.bool".to_string(), PrefValue::Bool(true));
        prefs.insert("test.int".to_string(), PrefValue::Int(42));

        write_user_js(dir.path(), &prefs).unwrap();

        let content = std::fs::read_to_string(dir.path().join("user.js")).unwrap();
        assert!(content.contains("user_pref(\"test.bool\", true);"));
        assert!(content.contains("user_pref(\"test.int\", 42);"));
    }

    #[test]
    fn test_write_user_js_string_escaping() {
        let dir = tempdir().unwrap();
        let mut prefs = HashMap::new();
        prefs.insert(
            "test.string".to_string(),
            PrefValue::String("hello \"world\" with\\backslash".to_string()),
        );

        write_user_js(dir.path(), &prefs).unwrap();

        let content = std::fs::read_to_string(dir.path().join("user.js")).unwrap();
        assert!(
            content.contains(r#"user_pref("test.string", "hello \"world\" with\\backslash");"#)
        );
    }

    #[test]
    fn test_write_user_js_header() {
        let dir = tempdir().unwrap();
        let prefs = HashMap::new();

        write_user_js(dir.path(), &prefs).unwrap();

        let content = std::fs::read_to_string(dir.path().join("user.js")).unwrap();
        assert!(content.contains("Generated by wolfpack"));
        assert!(content.contains("Do not edit manually"));
    }

    #[test]
    fn test_write_user_js_sorted() {
        let dir = tempdir().unwrap();
        let mut prefs = HashMap::new();
        prefs.insert("z.pref".to_string(), PrefValue::Bool(true));
        prefs.insert("a.pref".to_string(), PrefValue::Bool(true));
        prefs.insert("m.pref".to_string(), PrefValue::Bool(true));

        write_user_js(dir.path(), &prefs).unwrap();

        let content = std::fs::read_to_string(dir.path().join("user.js")).unwrap();
        let a_pos = content.find("a.pref").unwrap();
        let m_pos = content.find("m.pref").unwrap();
        let z_pos = content.find("z.pref").unwrap();

        assert!(a_pos < m_pos);
        assert!(m_pos < z_pos);
    }

    #[test]
    fn test_should_include_exact_match() {
        let whitelist = vec!["browser.startup.homepage".to_string()];
        assert!(should_include("browser.startup.homepage", &whitelist));
        assert!(!should_include("browser.startup.page", &whitelist));
    }

    #[test]
    fn test_should_include_wildcard() {
        let whitelist = vec!["browser.startup.*".to_string()];
        assert!(should_include("browser.startup.homepage", &whitelist));
        assert!(should_include("browser.startup.page", &whitelist));
        assert!(!should_include("browser.tabs.newtab", &whitelist));
    }

    #[test]
    fn test_should_include_multiple_patterns() {
        let whitelist = vec![
            "browser.startup.*".to_string(),
            "extensions.enabled".to_string(),
        ];
        assert!(should_include("browser.startup.homepage", &whitelist));
        assert!(should_include("extensions.enabled", &whitelist));
        assert!(!should_include("extensions.disabled", &whitelist));
    }

    #[test]
    fn test_should_include_empty_whitelist() {
        let whitelist: Vec<String> = vec![];
        assert!(!should_include("browser.startup.homepage", &whitelist));
    }

    #[test]
    fn test_read_prefs() {
        let dir = tempdir().unwrap();
        let prefs_content = r#"
// Comment line
user_pref("browser.startup.homepage", "https://example.com");
user_pref("browser.tabs.loadInBackground", true);
user_pref("browser.tabs.maxOpenBeforeWarn", 15);
user_pref("unrelated.pref", "ignored");
"#;
        std::fs::write(dir.path().join("prefs.js"), prefs_content).unwrap();

        let whitelist = vec!["browser.*".to_string()];
        let prefs = read_prefs(dir.path(), &whitelist).unwrap();

        assert_eq!(prefs.len(), 3);
        assert_eq!(
            prefs.get("browser.startup.homepage"),
            Some(&PrefValue::String("https://example.com".to_string()))
        );
        assert_eq!(
            prefs.get("browser.tabs.loadInBackground"),
            Some(&PrefValue::Bool(true))
        );
        assert_eq!(
            prefs.get("browser.tabs.maxOpenBeforeWarn"),
            Some(&PrefValue::Int(15))
        );
        assert!(!prefs.contains_key("unrelated.pref"));
    }

    #[test]
    fn test_read_prefs_nonexistent() {
        let dir = tempdir().unwrap();
        let result = read_prefs(dir.path(), &["browser.*".to_string()]);
        assert!(result.is_err());
    }

    #[test]
    fn test_read_prefs_empty_whitelist() {
        let dir = tempdir().unwrap();
        let prefs_content = r#"user_pref("browser.startup.homepage", "https://example.com");"#;
        std::fs::write(dir.path().join("prefs.js"), prefs_content).unwrap();

        let prefs = read_prefs(dir.path(), &[]).unwrap();
        assert!(prefs.is_empty());
    }
}
